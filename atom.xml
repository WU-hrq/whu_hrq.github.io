<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序猿QQ的个人博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.wacj.top/"/>
  <updated>2018-07-23T15:22:34.190Z</updated>
  <id>https://www.wacj.top/</id>
  
  <author>
    <name>程序猿QQ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java线程池浅析</title>
    <link href="https://www.wacj.top/2018/06/23/Executors/"/>
    <id>https://www.wacj.top/2018/06/23/Executors/</id>
    <published>2018-06-23T00:56:45.000Z</published>
    <updated>2018-07-23T15:22:34.190Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>Java线程池Executors简单源码分析</p></blockquote> <a id="more"></a><hr><h2 id="Executors：创建线程池类型"><a href="#Executors：创建线程池类型" class="headerlink" title="Executors：创建线程池类型"></a>Executors：创建线程池类型</h2><blockquote><p>newCachedThreadPool() 返回不限定最大线程数量的线程池，若无任务则不创建线程，来任务时创建线程执行，并且每个空闲线程会在60秒后被回收<br>newFixedThreadPool()  返回固定线程数量的线程池，核心线程数和最大线程数是一样的<br>newScheduledThreadPool() 可指定核心线程数量</p></blockquote><p>提前说明下，这几种线程池底层都是调用的ThreadPoolExecutor类对象，ThreadPoolExecutor类构造方法参数为：<br>第一个参数是核心线程数：corePoolSize<br>第一个参数是最大线程数：maximumPoolSize<br>第一个参数是线程存活时间：keepAliveTime<br>第四个参数是TimeUnit对象：TimeUnit<br>第五个参数是任务等待队列：BlockingQueue<br>第六个参数是拒绝策略：(默认是)AbortPolicy</p><p>下面看下每种线程池：</p><h2 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool():"></a>Executors.newCachedThreadPool():</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CachedThreadPool线程池是不限定最大线程数量的线程池，若无任务到来则不创建线程，来任务时创建线程执行，并且每个空闲线程会在60秒后被回收。<br>其采用的任务等待队列是SynchronousQueue，是无缓冲队列，队列中不放任务，来任务后新建线程并直接交给线程处理，若无线程可创建，则执行拒绝策略。</p><h2 id="Executors-newFixedThreadPool-10"><a href="#Executors-newFixedThreadPool-10" class="headerlink" title="Executors.newFixedThreadPool(10):"></a>Executors.newFixedThreadPool(10):</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>FixedThreadPool线程池返回固定线程数量的线程池，核心线程数和最大线程数是一样的。其采用的任务等待队列是LinkedBlockingDeque，是无界队列，<br>来任务后，若线程池线程数不超过核心线程数,则新建线程处理该任务，若达到了核心线程数，则一直将任务加入无界队列，直到耗尽系统资源。</p><h2 id="Executors-newScheduledThreadPool-10"><a href="#Executors-newScheduledThreadPool-10" class="headerlink" title="Executors.newScheduledThreadPool(10):"></a>Executors.newScheduledThreadPool(10):</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//ScheduledThreadPoolExecutor类继承了ThreadPoolExecutor类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">ScheduledThreadPoolExecutor</span>(<span class="title">int</span> <span class="title">corePoolSize</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到ScheduledThreadPool线程池底层也是调用ThreadPoolExecutor类，创建时指定核心线程数量即可。其采用的任务等待队列是DelayedWorkQueue，是延迟队列，可以设定任务延迟多久再执行。<br>还有种任务等待队列是有界队列：ArrayBlockingQueue，使用该队列时，来任务后，若线程池线程数不超过核心线程数，则新建线程处理该任务，若达到了核心线程数，则将任务加入有界队列。<br>当有界队列满时，判断线程池线程数是否达到最大线程数，没达到则创建新线程处理，达到则执行拒绝策略。</p><h2 id="线程池拒绝策略"><a href="#线程池拒绝策略" class="headerlink" title="线程池拒绝策略"></a>线程池拒绝策略</h2><blockquote><p>java的线程池拒绝策略有：</p></blockquote><p>AbortPolicy: 默认的拒绝策略，抛出异常，但系统正常工作<br>CallerRunsPolicy：只要线程池未关闭，则运行当前被丢弃的任务<br>DiscardOldestPolicy: 丢弃等待队列最早的请求，尝试再次提交当前任务<br>DiscardPolicy: 丢弃无法处理的任务，不做任何处理</p><p>此外，可以自定义拒绝策略(默认的几种拒绝策略不是很好)，只需要实现RejectedExecutionHandler接口，重写rejectedExecution方法即可。<br>处理逻辑可以把无法处理的任务记录日志，之后空闲时去处理。或者给任务发送端回应，让其等短一段时间再发任务。</p><hr><p>如有错误，务必指出，十分感谢。</p><p>作者 ：程序猿QQ<br>2018年 06月 23日    </p><hr><h2 id="日常歌曲推荐"><a href="#日常歌曲推荐" class="headerlink" title="日常歌曲推荐"></a>日常歌曲推荐</h2><blockquote><p>A Story of Fate - Jannik</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=512989806&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Java线程池Executors简单源码分析&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="https://www.wacj.top/categories/Java/"/>
    
    
      <category term="ThreadPool" scheme="https://www.wacj.top/tags/ThreadPool/"/>
    
      <category term="Java" scheme="https://www.wacj.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>XMPP协议SASL认证流程</title>
    <link href="https://www.wacj.top/2018/06/20/XMPPSASL/"/>
    <id>https://www.wacj.top/2018/06/20/XMPPSASL/</id>
    <published>2018-06-20T00:56:45.000Z</published>
    <updated>2018-07-22T04:37:23.652Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>XMPP协议SASL认证流程—以openfire服务器为例</p></blockquote> <a id="more"></a><hr><h2 id="XMPP协议的完整登录流程为："><a href="#XMPP协议的完整登录流程为：" class="headerlink" title="XMPP协议的完整登录流程为："></a>XMPP协议的完整登录流程为：</h2><blockquote><ul><li>TLS协商，构建加密通道</li><li>SASL协商，进行登录验证</li><li>SASL协商后即登录成功，之后进行资源绑定（用户可能通过手机或电脑等登陆）</li></ul></blockquote><p>这里主要讨论SASL协商，假设现在已建立好TLS加密通道。</p><h2 id="step1-客户端向服务器发送一个新的xml流。"><a href="#step1-客户端向服务器发送一个新的xml流。" class="headerlink" title="step1 客户端向服务器发送一个新的xml流。"></a>step1 客户端向服务器发送一个新的xml流。</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns</span>=<span class="string">'jabber:client'</span> <span class="attr">to</span>=<span class="string">'localhost'</span> <span class="attr">xmlns:stream</span>=<span class="string">'http://etherx.jabber.org/streams'</span> <span class="attr">version</span>=<span class="string">'1.0'</span> <span class="attr">from</span>=<span class="string">'zhangsan@localhost'</span> <span class="attr">xml:lang</span>=<span class="string">'en'</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="step2-服务器向服务器发送响应流-声明服务器支持的SASL验证机制。"><a href="#step2-服务器向服务器发送响应流-声明服务器支持的SASL验证机制。" class="headerlink" title="step2 服务器向服务器发送响应流, 声明服务器支持的SASL验证机制。"></a>step2 服务器向服务器发送响应流, 声明服务器支持的SASL验证机制。</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version='1.0' encoding='UTF-8'?&gt;<span class="tag">&lt;<span class="name">stream:stream</span> <span class="attr">xmlns:stream</span>=<span class="string">"http://etherx.jabber.org/streams"</span> <span class="attr">xmlns</span>=<span class="string">"jabber:client"</span> <span class="attr">from</span>=<span class="string">"localhost"</span> <span class="attr">id</span>=<span class="string">"45ulb20rwb"</span> <span class="attr">xml:lang</span>=<span class="string">"en"</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">stream:features</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mechanisms</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>PLAIN<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>SCRAM-SHA-1<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>CRAM-MD5<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mechanism</span>&gt;</span>DIGEST-MD5<span class="tag">&lt;/<span class="name">mechanism</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mechanisms</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">compression</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/features/compress"</span>&gt;</span><span class="tag">&lt;<span class="name">method</span>&gt;</span>zlib<span class="tag">&lt;/<span class="name">method</span>&gt;</span><span class="tag">&lt;/<span class="name">compression</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ver</span> <span class="attr">xmlns</span>=<span class="string">"urn:xmpp:features:rosterver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">register</span> <span class="attr">xmlns</span>=<span class="string">"http://jabber.org/features/iq-register"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">stream:features</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="step3-客户端向服务器发送auth流，声明客户端选择的SASL验证机制，openfire服务器默认是SCRAM-SHA-1"><a href="#step3-客户端向服务器发送auth流，声明客户端选择的SASL验证机制，openfire服务器默认是SCRAM-SHA-1" class="headerlink" title="step3 客户端向服务器发送auth流，声明客户端选择的SASL验证机制，openfire服务器默认是SCRAM-SHA-1"></a>step3 客户端向服务器发送auth流，声明客户端选择的SASL验证机制，openfire服务器默认是SCRAM-SHA-1</h2><p>auth流内容：<br>n=用户名<br>r=客户端随机数<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">auth</span> <span class="attr">xmlns</span>=<span class="string">'urn:ietf:params:xml:ns:xmpp-sasl'</span> <span class="attr">mechanism</span>=<span class="string">'SCRAM-SHA-1'</span>&gt;</span>biwsbj16aGFuZ3NhbixyPSNhTTRWeHdjO2ZzckZ2M3tuXnxHMVlTWWwzQEdCI1Va<span class="tag">&lt;/<span class="name">auth</span>&gt;</span></span><br><span class="line"></span><br><span class="line">经过base64解码后：n,,n=zhangsan,r=#aM4Vxwc;fsrFv3&#123;n^|G1YSYl3@GB#UZ</span><br></pre></td></tr></table></figure></p><p>—————前方高能————————<br>发现网上不少博客说的都是PLAIN机制的验证流程，此处从源码层面剖析下SCRAM-SHA-1机制。因为PLAIN机制，客户端会把用户名和密码发给服务器，不经过加密，只是base64编码了一下。服务器会从数据库(例如mysql数据库)的ofUser表中取出密码，解密后与客户端传来的密码比对即可。不够安全。感兴趣可以看下SaslServerPlainImpl类的evaluateResponse方法。</p><pre><code>下面介绍SCRAM-SHA-1的流程。服务器接收到auth流后，StanzaHandler类的process方法会被调用。process方法关键代码如下：</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"auth"</span>.equals(tag)) &#123;</span><br><span class="line">    startedSASL = <span class="keyword">true</span>;</span><br><span class="line">    saslStatus = SASLAuthentication.handle(session, doc);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (startedSASL &amp;&amp; <span class="string">"response"</span>.equals(tag) || <span class="string">"abort"</span>.equals(tag)) &#123;</span><br><span class="line">    saslStatus = SASLAuthentication.handle(session, doc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断xml流的类型是auth后，会调用SASLAuthentication.handle()方法，其实之后客户端发来的response流或abort流也是调用该方法。handle方法中会判断该xml流是auth还是response。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">switch</span> ( ElementType.valueOfCaseInsensitive( doc.getName() ) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> ABORT:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SaslFailureException( Failure.ABORTED );</span><br><span class="line">                <span class="keyword">case</span> AUTH:</span><br><span class="line">                    ...</span><br><span class="line">                    SaslServer saslServer = Sasl.createSaslServer( mechanismName, <span class="string">"xmpp"</span>, serverName, props, <span class="keyword">new</span> XMPPCallbackHandler() );</span><br><span class="line">                    ...</span><br><span class="line">                    session.setSessionData( <span class="string">"SaslServer"</span>, saslServer );</span><br><span class="line">                    ...</span><br><span class="line">                <span class="keyword">case</span> RESPONSE:</span><br><span class="line">                    <span class="comment">// Either a challenge or success data.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">byte</span>[] challenge = saslServer.evaluateResponse( decoded );</span><br></pre></td></tr></table></figure></p><p>判断是auth后，主要就是创建了Saslserver服务器，会根据之前所选的SASL验证机制创建对应的服务器。此处创建的是ScramSha1SaslServer服务器，在SaslServerFactoryImpl类的createSaslServer方法中创建，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"PLAIN"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SaslServerPlainImpl( protocol, serverName, props, cbh );</span><br><span class="line"><span class="keyword">case</span> <span class="string">"SCRAM-SHA-1"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScramSha1SaslServer();</span><br><span class="line"><span class="keyword">case</span> <span class="string">"ANONYMOUS"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnonymousSaslServer( session );</span><br><span class="line"><span class="keyword">case</span> <span class="string">"EXTERNAL"</span>:</span><br><span class="line">    <span class="keyword">if</span> ( session <span class="keyword">instanceof</span> LocalClientSession )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExternalClientSaslServer( (LocalClientSession) session );</span><br><span class="line">    <span class="keyword">if</span> ( session <span class="keyword">instanceof</span> LocalIncomingServerSession )</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExternalServerSaslServer( (LocalIncomingServerSession) session );</span><br><span class="line"><span class="keyword">case</span> JiveSharedSecretSaslServer.NAME:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JiveSharedSecretSaslServer();</span><br></pre></td></tr></table></figure></p><p>ScramSha1SaslServer类会在收到auth流后向客户端发送challenge流，之后客户端会发出应答流response，经过SASLAuthentication.handle()方法处理后也是交给ScramSha1SaslServer类进行验证。</p><p>—————前方极度高能————————<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> State state = State.INITIAL;    <span class="comment">//state初始化时的状态</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (state)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> INITIAL:</span><br><span class="line">            challenge = generateServerFirstMessage(response);</span><br><span class="line">            state = State.IN_PROGRESS;    <span class="comment">//服务器发送challenge后状态变为IN_PROGRESS</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IN_PROGRESS:</span><br><span class="line">            challenge = generateServerFinalMessage(response);</span><br><span class="line">            state = State.COMPLETE;    <span class="comment">//服务器验证完response后状态变为COMPLETE</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (response == <span class="keyword">null</span> || response.length == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                challenge = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"No response expected in state "</span> + state);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="step4-generateServerFirstMessage方法负责对auth流进行处理并发出challenge流。"><a href="#step4-generateServerFirstMessage方法负责对auth流进行处理并发出challenge流。" class="headerlink" title="step4 generateServerFirstMessage方法负责对auth流进行处理并发出challenge流。"></a>step4 generateServerFirstMessage方法负责对auth流进行处理并发出challenge流。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateServerFirstMessage(<span class="keyword">final</span> <span class="keyword">byte</span>[] response) <span class="keyword">throws</span> SaslException &#123;</span><br><span class="line">    String clientFirstMessage = <span class="keyword">new</span> String(response, StandardCharsets.UTF_8);</span><br><span class="line">    Matcher m = CLIENT_FIRST_MESSAGE.matcher(clientFirstMessage);</span><br><span class="line">    <span class="keyword">if</span> (!m.matches()) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"Invalid first client message"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    clientFirstMessageBare = m.group(<span class="number">5</span>);</span><br><span class="line">    username = m.group(<span class="number">6</span>);   <span class="comment">//从auth流中得到用户名</span></span><br><span class="line">    String clientNonce = m.group(<span class="number">7</span>);    <span class="comment">//从auth流中得到客户端随机数</span></span><br><span class="line">    nonce = clientNonce + UUID.randomUUID().toString();    <span class="comment">//对客户端随机数再次随机，之后会对其验证</span></span><br><span class="line">    serverFirstMessage = String.format(<span class="string">"r=%s,s=%s,i=%d"</span>, nonce, DatatypeConverter.printBase64Binary(getSalt(username)),getIterations(username));    <span class="comment">//准备发给客户端的challenge流</span></span><br><span class="line">    <span class="keyword">return</span> serverFirstMessage.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>challenge流内容：<br>r=服务端随机数(客户端随机数+UUID)<br>s=salt(base64编码的盐，存储在openfiref服务端数据库的ofUser表中)<br>i =迭代次数(存储在openfiref服务端数据库的ofUser表中)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">challenge</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span>cj0jYU00Vnh3Yztmc3JGdjN7bl58RzFZU1lsM0BHQiNVWjA3MzAzYzgwLWM2YTctNGRjMC1iZmUyLWVjODNlYmJmY2FlMCxzPVdmckVRTXVmZVdCSmoxS0dUR0p5aVJuaGIrWVJFQzZKLGk9NDA5Ng==<span class="tag">&lt;/<span class="name">challenge</span>&gt;</span></span><br><span class="line"></span><br><span class="line">解码后内容为：r=#aM4Vxwc;fsrFv3&#123;n^|G1YSYl3@GB#UZ07303c80-c6a7-4dc0-bfe2-ec83ebbfcae0,s=WfrEQMufeWBJj1KGTGJyiRnhb+YREC6J,i=4096</span><br></pre></td></tr></table></figure><h2 id="step5-客户端会根据用户输入密码、从服务器challenge流中获得的盐和迭代次数，计算出一些数值，并作为response流发给服务器去验证。"><a href="#step5-客户端会根据用户输入密码、从服务器challenge流中获得的盐和迭代次数，计算出一些数值，并作为response流发给服务器去验证。" class="headerlink" title="step5 客户端会根据用户输入密码、从服务器challenge流中获得的盐和迭代次数，计算出一些数值，并作为response流发给服务器去验证。"></a>step5 客户端会根据用户输入密码、从服务器challenge流中获得的盐和迭代次数，计算出一些数值，并作为response流发给服务器去验证。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">clientFinalMessageBare = <span class="string">"c=biws,r=服务端随机数"</span></span><br><span class="line">saltedPassword = PBKDF2-SHA-<span class="number">1</span>(normalizedPassword, salt, i)</span><br><span class="line">clientKey = HMAC-SHA-<span class="number">1</span>(saltedPassword, <span class="string">"客户端密钥"</span>)</span><br><span class="line">storedKey = SHA-<span class="number">1</span>(clientKey)</span><br><span class="line">authMessage = auth流内容+<span class="string">","</span>+challenge流内容+<span class="string">","</span>clientFinalMessageBare</span><br><span class="line">clientSignature = HMAC-SHA-<span class="number">1</span>(storedKey, authMessage)</span><br><span class="line">clientProof = clientKey 异或 clientSignature</span><br><span class="line">serverKey = HMAC-SHA-<span class="number">1</span>(saltedPassword, <span class="string">"服务端密钥"</span>)</span><br><span class="line">serverSignature = HMAC-SHA-<span class="number">1</span>(serverKey, authMessage)</span><br><span class="line">clientFinalMessage = clientFinalMessageBare<span class="string">",p="</span>base64(clientProof)<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">客户端对clientFinalMessage进行base64编码并将其作为response流发送给服务器</span></span><br></pre></td></tr></table></figure><p>response流内容：<br>c=biws<br>r=服务端随机数<br>p=base64(clientProof)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">response</span> <span class="attr">xmlns</span>=<span class="string">'urn:ietf:params:xml:ns:xmpp-sasl'</span>&gt;</span>Yz1iaXdzLHI9I2FNNFZ4d2M7ZnNyRnYze25efEcxWVNZbDNAR0IjVVowNzMwM2M4MC1jNmE3LTRkYzAtYmZlMi1lYzgzZWJiZmNhZTAscD1QdUE5OGVSVXBBSGhqa2EwdDJ3dVQ1TFBvU1k9<span class="tag">&lt;/<span class="name">response</span>&gt;</span></span><br><span class="line"></span><br><span class="line">解码后内容为：c=biws,r=#aM4Vxwc;fsrFv3&#123;n^|G1YSYl3@GB#UZ07303c80-c6a7-4dc0-bfe2-ec83ebbfcae0,p=PuA98eRUpAHhjka0t2wuT5LPoSY=</span><br></pre></td></tr></table></figure></p><h2 id="step6-ScramSha1SaslServer类的generateServerFinalMessage方法负责对response流进行验证，验证通过会向客户端发送success流。"><a href="#step6-ScramSha1SaslServer类的generateServerFinalMessage方法负责对response流进行验证，验证通过会向客户端发送success流。" class="headerlink" title="step6 ScramSha1SaslServer类的generateServerFinalMessage方法负责对response流进行验证，验证通过会向客户端发送success流。"></a>step6 ScramSha1SaslServer类的generateServerFinalMessage方法负责对response流进行验证，验证通过会向客户端发送success流。</h2><p>generateServerFinalMessage方法核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">String clientFinalMessage = <span class="keyword">new</span> String(response, StandardCharsets.UTF_8);</span><br><span class="line">Matcher m = CLIENT_FINAL_MESSAGE.matcher(clientFinalMessage);</span><br><span class="line">String clientFinalMessageWithoutProof = m.group(<span class="number">1</span>);</span><br><span class="line">String clientNonce = m.group(<span class="number">3</span>);    <span class="comment">//客户端发来的服务器随机数</span></span><br><span class="line">String proof = m.group(<span class="number">4</span>);    <span class="comment">//base64(clientProof)</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!nonce.equals(clientNonce)) &#123;    <span class="comment">//验证服务器之前生成的随机数和客户端发来的服务器随机数是否一致</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"Client final message has incorrect nonce value"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String authMessage = clientFirstMessageBare + <span class="string">","</span> + serverFirstMessage + <span class="string">","</span> + clientFinalMessageWithoutProof;</span><br><span class="line">            <span class="keyword">byte</span>[] storedKey = getStoredKey( username );    <span class="comment">//根据用户名查找服务端存储的storedKey</span></span><br><span class="line">            <span class="keyword">if</span> (storedKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"No stored key for user '"</span>+username+<span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">byte</span>[] serverKey = getServerKey(username);    <span class="comment">//根据用户名查找服务端存储的serverKey</span></span><br><span class="line">            <span class="keyword">if</span> (serverKey == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"No server key for user '"</span>+username+<span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] clientSignature = ScramUtils.computeHmac(storedKey, authMessage);</span><br><span class="line">            <span class="keyword">byte</span>[] serverSignature = ScramUtils.computeHmac(serverKey, authMessage);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">byte</span>[] clientKey = clientSignature.clone();</span><br><span class="line">            <span class="keyword">byte</span>[] decodedProof = DatatypeConverter.parseBase64Binary(proof);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientKey.length; i++) &#123;</span><br><span class="line">                clientKey[i] ^= decodedProof[i];    <span class="comment">//将clientProof与clientSignature进行异或，还原出clientKey</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将服务端存储的storedKey和clientKey经SHA-1算法得到值进行比对</span></span><br><span class="line">            <span class="keyword">if</span> (!Arrays.equals(storedKey, MessageDigest.getInstance(<span class="string">"SHA-1"</span>).digest(clientKey))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SaslException(<span class="string">"Authentication failed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//比对成功则表明验证成功，向客户端发送success流</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="string">"v="</span> + DatatypeConverter.printBase64Binary(serverSignature))</span><br><span class="line">                    .getBytes(StandardCharsets.UTF_8);</span><br></pre></td></tr></table></figure></p><p>————————-关键点————————————-<br>客户端：clientKey 异或 clientSignature = clientProof<br>服务端：clientProof异或clientSignature=clientKey，便可还原出clientKey。再将服务端存储的storedKey和clientKey经SHA-1算法得到值进行比对，即可完成验证。</p><p>success流内容：<br>v=base64(serverSignature)<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">success</span> <span class="attr">xmlns</span>=<span class="string">"urn:ietf:params:xml:ns:xmpp-sasl"</span>&gt;</span>dj1WZUtxOFFTRFBTbXdaNUM2V1hvanZTTzJwdTA9<span class="tag">&lt;/<span class="name">success</span>&gt;</span></span><br><span class="line"></span><br><span class="line">解码后内容为：v=VeKq8QSDPSmwZ5C6WXojvSO2pu0=</span><br></pre></td></tr></table></figure></p><p>至此，XMPP协议的SASL协商完成，之后客户端发送新的流，完成资源绑定等流程。<br>Tip: 建议下载openfire源码跑一下流程。</p><hr><p>如有错误，务必指出，十分感谢。</p><p>作者 ：程序猿QQ<br>2018年 06月 20日    </p><hr><h2 id="日常歌曲推荐"><a href="#日常歌曲推荐" class="headerlink" title="日常歌曲推荐"></a>日常歌曲推荐</h2><blockquote><p>secret base ~君がくれたもの~ (10 years after Ver.)</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=33911781&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;XMPP协议SASL认证流程—以openfire服务器为例&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="XMPP" scheme="https://www.wacj.top/categories/XMPP/"/>
    
    
      <category term="XMPP" scheme="https://www.wacj.top/tags/XMPP/"/>
    
      <category term="SASL" scheme="https://www.wacj.top/tags/SASL/"/>
    
  </entry>
  
  <entry>
    <title>30万知乎用户数据爬虫分析</title>
    <link href="https://www.wacj.top/2018/05/26/zhihu-pachong/"/>
    <id>https://www.wacj.top/2018/05/26/zhihu-pachong/</id>
    <published>2018-05-25T16:56:45.000Z</published>
    <updated>2018-07-22T04:44:55.655Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>爬取知乎30万用户信息（去重后），并从爬取数据的各维度进行分析，探索知乎用户群体的一些规律。</p></blockquote> <a id="more"></a><hr><h2 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h2><ul><li>采用MongoDB存储数据</li><li>为应对单个ip爬取被封的情况，采用代理ip池进行爬虫</li><li>为提高爬取速度，采用多线程进行爬取（采用python语言）</li><li>为提高用户质量，只爬取用户的关注列表</li><li>图表展示采用<a href="https://me.bdp.cn/home.html" target="_blank" rel="noopener">BDP</a>，一款云端可视化数据分析工具</li></ul><h2 id="用户分析"><a href="#用户分析" class="headerlink" title="用户分析"></a>用户分析</h2><blockquote><p>本分析不具有代表性,只针对已爬取的30万数据</p></blockquote><p>展示图表如下：</p><ul><li><p>知乎用户性别对比<br><img src="/images/知乎用户性别对比.png" alt="知乎用户性别对比">可以看出知乎用户群体中男性占比最大，女性其次，还有一部分用户性别未知，难道有其他性别？</p></li><li><p>知乎用户粉丝数量排名<br><img src="/images/知乎用户粉丝数量排名.png" alt="知乎用户粉丝数量排名">张公子领跑粉丝数量排行榜，粉丝数量超过150多万。丁香医生、李开复粉丝数量也超过100万大关，轮子哥排名也非常靠前。</p></li><li><p>知乎用户获得感谢数量排名<br><img src="/images/知乎用户获得感谢数量排名.png" alt="知乎用户获得感谢数量排名">张公子继续领跑感谢数量排行榜</p></li><li><p>知乎用户获赞数量排名<br><img src="/images/知乎用户获赞数量排名.png" alt="知乎用户获赞数量排名">张公子还是领跑获赞数量排行榜，快突破500万大关了。</p></li><li><p>知乎用户行业分布<br><img src="/images/知乎用户行业分布.png" alt="知乎用户行业分布">从知乎用户行业分布中可以看出，IT行业牢牢占据榜首，教育、金融、法律和医学等领域排名也很靠前。</p></li><li><p>知乎用户院校分布<br><img src="/images/知乎用户院校分布.png" alt="知乎用户院校分布">知乎用户就读院校Top10清一色985，不是清北真是不好意思往上写。</p></li><li><p>知乎用户现居地分布<br><img src="/images/知乎用户现居地分布.png" alt="知乎用户现居地分布">从知乎用户居住地可以看出，知乎用户主要活跃在北上广深等一线城市。</p></li><li><p>知乎用户个人简介词频统计<br><img src="/images/知乎用户个人简介词频统计.png" alt="知乎用户个人简介词频统计">从知乎用户个人简介词频统计可以看出，知乎的用户群体学生占比比较大。</p></li><li><p>知乎用户个性签名词频统计<br><img src="/images/知乎用户个性签名词频统计.png" alt="知乎用户个性签名词频统计">从知乎用户个性签名词频统计可以看出，用户倾向在个性签名中填写职业相关的信息。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>爬取的用户数量不是很大，没有很强的代表性；</li><li>可以进一步进行用户相关性分析；</li></ul><hr><h2 id="日常歌曲推荐"><a href="#日常歌曲推荐" class="headerlink" title="日常歌曲推荐"></a>日常歌曲推荐</h2><blockquote><p>牵丝戏 - 银临/Aki阿杰</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=30352891&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;爬取知乎30万用户信息（去重后），并从爬取数据的各维度进行分析，探索知乎用户群体的一些规律。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="爬虫" scheme="https://www.wacj.top/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://www.wacj.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="知乎" scheme="https://www.wacj.top/tags/%E7%9F%A5%E4%B9%8E/"/>
    
  </entry>
  
  <entry>
    <title>Github博客绑定个性域名</title>
    <link href="https://www.wacj.top/2018/05/20/github-domain/"/>
    <id>https://www.wacj.top/2018/05/20/github-domain/</id>
    <published>2018-05-19T16:56:24.000Z</published>
    <updated>2018-07-22T04:45:22.223Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>首先我们先买个域名,可以在<a href="https://cn.aliyun.com/" target="_blank" rel="noopener">阿里云</a><img id="github-emoji" alt="cloud" src="https://assets-cdn.github.com/images/icons/emoji/unicode/2601.png?v8" height="20" width="20">购买域名，买完之后登陆阿里云管理控制台,然后点击域名，再点击解析如下。</p></blockquote> <a id="more"></a><hr><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p><img src="http://upload-images.jianshu.io/upload_images/5308475-4953432e1dae183e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="阿里云管理控制台"></p><p>接下来点击添加解析，并输入以下信息（记录值不一样，第一个的记录值填你的github访问地址,如wu-hrq.github.io,第二个填的是你的网站的ip地址，比如我原来的网站是wu-hrq.github.io,那么就查找wu-hrq.github.io的ip地址，网站的ip地址可以在这查<a href="http://ip.chinaz.com/" target="_blank" rel="noopener">ip地址</a>。</p><p><img src="http://upload-images.jianshu.io/upload_images/5308475-8b27bab6a8c389d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ip地址"></p><p>然后向你的 Github Pages 仓库添加一个CNAME(一定要大写)文件，在CNAME里面添加你的域名信息（不加http://），如shenzekun.cn,并上传到你的GitHub中</p><p>填完之后登陆你博客的github，点击setting<br><img src="http://upload-images.jianshu.io/upload_images/5308475-d73094344c7c7f6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="setting"></p><p>在这填写你的域名，点击保存即可<br><img src="http://upload-images.jianshu.io/upload_images/5308475-86c99fdf87c8fef8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名"></p><p>接下来就是等了，我的博客大概半个小时就可以看到了。😝</p><hr><h2 id="日常歌曲推荐"><a href="#日常歌曲推荐" class="headerlink" title="日常歌曲推荐"></a>日常歌曲推荐</h2><blockquote><p>浮生未歇 - 音频怪物</p></blockquote><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=184557&auto=0&height=66"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首先我们先买个域名,可以在&lt;a href=&quot;https://cn.aliyun.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阿里云&lt;/a&gt;&lt;img id=&quot;github-emoji&quot; alt=&quot;cloud&quot; src=&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/2601.png?v8&quot; height=&quot;20&quot; width=&quot;20&quot;&gt;购买域名，买完之后登陆阿里云管理控制台,然后点击域名，再点击解析如下。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Github" scheme="https://www.wacj.top/categories/Github/"/>
    
    
      <category term="博客" scheme="https://www.wacj.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="域名" scheme="https://www.wacj.top/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="Github" scheme="https://www.wacj.top/tags/Github/"/>
    
  </entry>
  
</feed>
